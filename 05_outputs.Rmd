# Outputs

## From long to large table
How to move from a tidy format to a large format

## Merge file
How to create a merge file

## Graphs
### spider graphs
### prison graphs

### Bar graphs

Loading libraries and the main dataset
```{r warning=F}
library(tidyverse)
library(ggplot2)
library(plotly)
library(openxlsx)
library(data.table)
library(reshape)

main_dataset <- read.csv("inputs/UKR2007_MSNA20_HH_dataset_main_rcop.csv", na.strings = "")
```


Choosing the needed indicator for building bar graph. The indicators in the questionnaire could be in 2 types: Only one answer can be selected (select_one question) and multiple answers can be selected (select_multiple question). Will review it separately.

1. For select one questions:

Preparing values for visualization (replacing xml values to lables) 
```{r warning=F}
# Loading questionnaire
questions <- read.xlsx("inputs/UKR2007_MSNA20_HH_Questionnaire_24JUL2020.xlsx", sheet = "survey", na.strings = "")
choices <- read.xlsx("inputs/UKR2007_MSNA20_HH_Questionnaire_24JUL2020.xlsx", sheet = "choices", na.strings = "")

# Based on value we get option type
q.list_name <- str_split(questions[questions$name == "b9_hohh_marital_status" & !is.na(questions$name), "type"], " ")[[1]][2]

# New table with xml and labels
labels <- choices %>%
  filter(list_name == q.list_name) %>%
  select(name, "label::English") %>%
  dplyr::rename(b9_hohh_marital_status = name, b9_hohh_marital_status_label = "label::English")

# Add a column with English labels to the main dataset
main_dataset <- merge(labels, main_dataset, by = 'b9_hohh_marital_status')
```


Building a bar graph
```{r warning=F}
ggplot((main_dataset %>%
          filter(!is.na(b9_hohh_marital_status_label)) %>%
          dplyr::group_by(b9_hohh_marital_status_label) %>%
          dplyr::summarize(weight_sum = round(sum(stratum.weight), 2))), aes(y = reorder(b9_hohh_marital_status_label, weight_sum), x = weight_sum/sum(weight_sum))) +
  geom_bar(stat = "identity", fill = "#EE5859") +
  geom_text(aes(label = paste(round((weight_sum/sum(weight_sum)*100),0),"%")), color = "#58585A", size = 4, hjust = -0.1) +
  scale_x_continuous(labels = scales::percent) +
  theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_text(color = "#58585A", size = 12),
  panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank())
```


Removing temporary data
```{r warning=F}
rm(labels, q.list_name)
```


2. For select multiple questions:

Preparing values for visualization (replacing xml values to lables; calculating results) 
```{r warning=F}
# Getting needed columns from the main dataset (indicator and weight)
visual_dataset <- main_dataset[,grepl("b10_hohh_vulnerability.|stratum.weight", names(main_dataset))]

# Reshaping the dataset
visual_dataset <- melt(visual_dataset, id.vars = "stratum.weight")

# Grouping by choices and getting sum of weights
visual_dataset <- visual_dataset %>%
  mutate(weight = stratum.weight * value) %>%
  group_by(variable) %>% 
  summarise(weight_sum = sum(as.numeric(weight))) %>%
  mutate(percentage = round(weight_sum / sum(main_dataset$stratum.weight)*100)) %>%
  dplyr::rename(b10_hohh_vulnerability = variable)

# Based on value we get option type and replacing xmls to the labels and 
q.list_name <- str_split(questions[questions$name == "b10_hohh_vulnerability" & !is.na(questions$name), "type"], " ")[[1]][2]

# New table with xml and labels
labels <- choices %>%
  filter(list_name == q.list_name) %>%
  select(name, "label::English") %>%
  dplyr::rename(b10_hohh_vulnerability = name, b10_hohh_vulnerability_label = "label::English") %>%
  mutate(b10_hohh_vulnerability = paste0("b10_hohh_vulnerability.", b10_hohh_vulnerability))

# Add a column with English labels to the visualization dataset
visual_dataset <- merge(labels, visual_dataset, by = 'b10_hohh_vulnerability')
```


Building a bar graph
```{r warning=F}
ggplot(visual_dataset, aes(y = reorder(b10_hohh_vulnerability_label, percentage), x = percentage)) +
  geom_bar(stat = "identity", fill = "#EE5859") +
  geom_text(aes(label = paste(percentage, "%")), color = "#58585A", size = 4, hjust = -0.1) +
  scale_x_continuous(labels = scales::percent) +
  theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_text(color = "#58585A", size = 12),
  panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank())
```


Removing temporary data
```{r warning=F}
rm(labels, q.list_name)
```


### Euler diagram
*An Euler diagram  is a diagrammatic means of representing sets and their relationships. They are particularly useful for explaining complex hierarchies and overlapping definitions. They are similar to another set diagramming technique, Venn diagrams. Unlike Venn diagrams, which show all possible relations between different sets, the Euler diagram shows only relevant relationships. [Source](https://en.wikipedia.org/wiki/Euler_diagram)*

First let's load [Eulerr library](https://cran.r-project.org/web/packages/eulerr/vignettes/introduction.html) and our dataset
```{r}
main_dataset <- read.csv("inputs/UKR2007_MSNA20_HH_dataset_main_rcop.csv", na.strings = "")
```

Euler diagrams are particularly useful to visualize overlaps between HH characteristics that help better understand the demographic profile of the area. For example, let's visualize overlaps between such HH characteristics as age, displacement status, income level, disability, and employment status.
```{r tidy=FALSE, message= F, warning=F, error=F, echo=T}
library(eulerr)
library(magrittr)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(UpSetR)

vulnerability_data <- main_dataset %>%
    select(b10_hohh_vulnerability.disability_not_including_chronic_illness,b10_hohh_vulnerability.older_person,
           b10_hohh_vulnerability.unemployed,d1_hh_displacement_status,b15_hohh_income,X_uuid, strata, stratum.weight)%>%
  #select all necessary columns
    mutate(displaced = ifelse(d1_hh_displacement_status == "no", 0, 1),
           low_income = ifelse(as.numeric(b15_hohh_income) >= 2189, 0, 1))%>% #2189 UAH(83$) is minimal monthly income in 2020
  #calculate binary indicators in case they are not available in the dataset directly from select multiple questions
    select(-d1_hh_displacement_status, -b15_hohh_income)%>%
    setNames(c("disability", "60+", "unemployed", "uuid", "strata", "weight", "displaced", "low_income"))
  #remove unnecessary columns and rename other column

vulnerability_data <- #create column that will combine all binary columns into one (same approach as in ### Re-generate text                             column  for select multiple questions section of Data Cleaning chapter)
    map2_df(vulnerability_data, names(vulnerability_data), ~  replace(.x, .x==1, .y) %>% 
    replace(. == 0, NA)) %>%
    unite(combined, disability, `60+`, displaced, low_income, unemployed, remove = FALSE, na.rm = TRUE, sep = '&')%>%
    filter(!combined == "")

#calculate weighted summary statistics for each combination
vulnerability_summary <- vulnerability_data %>%
  select(strata, weight, combined)%>% 
  group_by(combined) %>% 
  summarise(weight_sum = sum(as.numeric(weight)))%>%
  mutate(per = weight_sum / sum(weight_sum) * 100)%>%
  filter(per > 1)%>%
  select(-weight_sum)

#convert data frame into named numeric vector that is used by plot function
vulnerability_input <-  vulnerability_summary %>%
                        deframe()
```

In this block we will build euler diagram using REACH color palette and some basic styling.
```{r}
plot(euler(vulnerability_input),
     edges = FALSE,
     quantities = list(type = "percent", fontsize = 8),
     labels = c("60+", "Displaced", "Low income", "Disability", "Unemployed"),
     legend = list(labels = c("60+", "Displaced", "Low income", "Disability", "Unemployed")),
     fills = c("#7CB6C4","#B6C8B1","#F6E3E3","#D1CAB8","#D1D3D4")
     )
```

As an alternative, we also can build a Venn diagram that shows each relation (even not possible in reality). As you can see Venn diagram in this case is less readable and usable.
```{r}
plot(venn(vulnerability_input),
     edges = FALSE,
     quantities = list(type = "percent", fontsize = 8), 
     labels = c("60+", "Displaced", "Low income", "Disability", "Unemployed"),
     legend = list(labels = c("60+", "Displaced", "Low income", "Disability", "Unemployed")),
     fills = c("#7CB6C4","#B6C8B1","#F6E3E3","#D1CAB8","#D1D3D4"))
```
Another popular type of diagram that shows relation is [UpSetR diagram](https://github.com/hms-dbmi/UpSetR). Even with default styling, it's quite good in the visualization of intersections between different HH characteristics.
```{r}
upset(fromExpression(vulnerability_input), order.by = "freq")
```

### Circular barplots

For creating circular barplots, frequency table with selected indicators should be prepared first.

For the current example, let's create the table on everyday consumption of different kinds of food in a HH depending on the area of living urban/rural

```{r}
library(dplyr)
library(tidyr)

main_dataset <- separate(main_dataset, strata, into = c("zone", "type"), "_")

dnames <- names(main_dataset)

cons_names <- dnames[grepl("consumption", dnames)]

tidy_names <- c("Cereals", "Roots", "Vegetables", "Fruits", "Meat", "Eggs", "Pulses", "Dairy", "Oil", "Sugar", "Condiments")

table_food <- as.data.frame(matrix(nrow = 0, ncol = 5))

i <- 1
for (i in 1:length(cons_names)) {
ni <- cons_names[i]

rur <- main_dataset |> filter(type == "rural") |> filter(!is.na(ni)) |> count(!!sym(ni)) |> mutate(base = sum(n), prop = round((n/base)*100, 0), group = tidy_names[i], individual = "Rural")

urb <- main_dataset |> filter(type == "urban") |> filter(!is.na(ni)) |> count(!!sym(ni)) |> mutate(base = sum(n), prop = round((n/base)*100, 0), group = tidy_names[i], individual = "Urban")

names(rur) <- c("fre_cons", "n", "base", "prop", "group", "individual")
names(urb) <- c("fre_cons", "n", "base", "prop", "group", "individual")

table_food <- rbind(table_food, rur, urb)
}

table_food$value <- table_food$prop
```

For the current chart, the everyday consumption of certain products will be selected, so frequency of consumption should be filtered so it is == 7

```{r}
table_food <- table_food |> filter(fre_cons == 7)
```


Adding "filler" field to make the bottom layer (unfilled space) with light grey. Filler should be equal to the "end of the scale", e.g 100%

```{r}
table_food$filler <- 100
```


Preparing grid data for the chart

```{r}
table_food$group <- as.factor(table_food$group)
# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 1
to_add <- data.frame( matrix(NA, empty_bar*nlevels(table_food$group), ncol(table_food)) )
colnames(to_add) <- colnames(table_food)
to_add$group <- rep(levels(table_food$group), each=empty_bar)
table_food <- rbind(table_food, to_add)
table_food <- table_food %>% arrange(group)
table_food$id <- seq(1, nrow(table_food))

#one more empty bar
to_add <- data.frame( matrix(NA, empty_bar*nlevels(table_food$group), ncol(table_food)) )
colnames(to_add) <- colnames(table_food)
to_add$group <- rep(levels(table_food$group), each=empty_bar)
table_food <- rbind(table_food, to_add)
table_food <- table_food %>% arrange(group)
table_food$id <- seq(1, nrow(table_food))
 
# Get the name and the y position of each label
label_data <- table_food
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -85, 1, 0)
label_data$angle <- ifelse(angle < -85, angle+180, angle)


 
# prepare a data frame for base lines
base_data <- table_food %>% 
  group_by(group) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))
 
# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]
 
##fixing grid data
grid_data$start = grid_data$start-0.2
grid_data$end = grid_data$end+0.2


#data$highlight = rev(levels(c("firebrick", "seagreen", "dimgray")))
cols = as.character(table_food$highlight[!is.na(table_food$highlight)])
cols = as.factor(cols)
levels(cols)



#label color - to put text within bars and placement of the label
#label_data$lab_color = ifelse(data$value > 10, "white", "black")
#label_data$lab_placement = ifelse(data$value > 10, data$value-(data$value-1), data$value-(data$value-6))
label_data$lab_color = "black"
label_data$lab_placement= table_food$value-(table_food$value-1)
```

Picking the treshold for highlighting a bar in different color. Let's put <= 10% in red, 11% - 50% in grey an 51% - 100% in green

```{r}
table_food <- table_food |> mutate(highlight = case_when(table_food$value <= 10 ~ "bad",
                                                         table_food$value >= 11 & table_food$value <= 50 ~ "moderate",
                                                         table_food$value >= 51 ~ "good"))
table_food$highlight = as.factor(table_food$highlight)
cols_u = unique(cols)
```



#### Adding thermometer sign (if needed)

```{r}
cat_low = rep("bad", 10)
cat_med = rep("moderate", 41)
cat_high = rep("good", 49)
thermometer = data.frame(cat  = c(cat_low, cat_med, cat_high),
                        number = c(rep(1,100)),
                        pos  = c(rep(1,100)))

thermometer$cat = ordered(thermometer$cat, levels=c("bad", "moderate", "good"))
ball = data.frame(v = 0,
                  h = 1)
                        
                        
t = ggplot(thermometer)+
geom_col(aes(x = pos, y = number, fill = cat), position = position_stack(reverse = T), width = 0.1)+
xlim(0,2)+
ylim(-5, 105)+
scale_fill_manual(breaks = c('bad', "moderate", "good"), values = c("moderate" = "dimgray", "good" = "seagreen", "bad" = "firebrick"))+
geom_point(data = ball, aes(x = h, y = v-5), color = "firebrick", size = 20)
```

#### Creating the plot itself

```{r}
p <- ggplot(table_food, aes(x=as.factor(id), y=value), width = 0.3) +       
# Note that id is a factor. If x is numeric,there is some space between the first bar

# Placing base layer of bars
  geom_bar(aes(x=as.factor(id), y=filler), fill="#E0E2E2", stat="identity", alpha=1) + 
  geom_bar(aes(x=as.factor(id), y=value, fill=highlight), stat="identity", alpha=1) + 
  scale_fill_manual(breaks = c("moderate", 'good', "bad"), values = c("moderate" = "#93A0A9", "good" = "#A5C9A1", "bad" = "#EE5859")) +
  
# Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  
 geom_segment(data=grid_data, aes(x = end, y = 75, xend = start, yend = 75), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
 geom_segment(data=grid_data, aes(x = end, y = 50, xend = start, yend = 50), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
geom_segment(data=grid_data, aes(x = end, y = 25, xend = start, yend = 25), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  

  
  
  geom_bar(aes(x=as.factor(id), y=filler), fill="#E0E2E2", stat="identity", alpha=1, width = 0.3,) +
  geom_bar(aes(x=as.factor(id), y=value, fill=highlight), stat="identity", alpha=1, width = 0.3,) +
  ylim(-70,120) +
  theme_minimal(base_family = "Arial") +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
    #plot.margin = unit(rep(-1,4), "cm"), 
  ) +
  coord_polar() + 
  # Add text showing the value of each 100/75/50/25 lines
 annotate("text", x = rep(max(table_food$id),3), y = c(25, 50, 75), label = c("25%", "50%", "75%") , color="grey", size=3 , angle=0, fontface="bold", hjust=1) +
  geom_text(data=label_data, aes(x=id, y=lab_placement, label=individual, hjust=hjust, ), color = "black", fontface="bold",alpha=0.8, size=4, angle= label_data$angle, inherit.aes = FALSE, family = "Arial Narrow") +
  geom_text(data=label_data, aes(x=id, y=lab_placement-10, label=value, hjust=hjust, ), color = "black", fontface="bold",alpha=0.8, size=3, angle= label_data$angle, inherit.aes = FALSE, family = "Arial Narrow")+
  geom_text(data=base_data, aes(x = title, y = -25, label=group))

p

```
#### Adding a text in the center of the plot

```{r}
p + geom_text(x = 0, aes(y = -65, label = "7 days / week"), size = 4.5, fontface = "bold", family = "Arial Narrow", color = "gray28")
```


#### Adding a thermometer object to the plot

```{r}
p +  geom_col(data = thermometer, aes(x = 43.5, y = number, fill = cat), position = position_stack(reverse = T), width = 0.3, angle = 0)+
geom_point(data = ball, aes(x = 43.5, y = v-2), color = "#EE5859", size = 5)+
geom_text(aes(x = 42.8, y = 5, label = "Freq. of consumption"), color = "black", fontface="bold",alpha=0.6, size=2.3, angle= 100, hjust = 0, family = "Arial Narrow")
```
```{r}
#rotating plot to have straight placement of thermometer
library(grid)
pushViewport(viewport(name = "rotate", angle = -6))
print(p, vp = "rotate")
```



```{r}
loadfonts()
getwd()
setwd("C:\\Users\\user\\Desktop\\Hanna K\\Plots\\Circular_barplots\\NEW_INDICATORS")
pdf("Myrne_210423.pdf", family = "Arial Narrow", width = 10, height = 10)
#p
pushViewport(viewport(name = "rotate", angle = -5))
print(p, vp = "rotate")
dev.off()

cairo_pdf("Myrne_210423.pdf", width = 11, height = 11, family = "Arial Narrow")
par(family = "Arial Narrow")
pushViewport(viewport(name = "rotate", angle = -5))
print(p, vp = "rotate")
dev.off()
```


### Venn diagram
### UpSet plots
### boxplots


## Labels
### change from xml to label
### change from label to xml

## Dashboarding - Sharing information
Html files
Tableau
Power BI
Shiny

## Outputs with hypothesis testing results
